defmodule MultiAgentCoder.Build.Monitor do
  @moduledoc """
  Monitors build processes for provider-generated code.

  Provides real-time monitoring of compilation, warnings, errors,
  and build progress for code generated by multiple AI providers.
  """

  require Logger

  @type build_result :: %{
          provider: atom(),
          success: boolean(),
          duration: integer(),
          warnings: list(String.t()),
          errors: list(String.t()),
          output: String.t(),
          timestamp: DateTime.t()
        }

  @doc """
  Monitors a build for a specific provider's code.

  ## Parameters
    - provider: Provider name (:openai, :anthropic, etc.)
    - project_dir: Directory containing the code to build
    - opts: Options
      - `:language` - Programming language (default: :elixir)
      - `:broadcast` - Broadcast progress updates (default: true)

  ## Returns
    `{:ok, build_result}` or `{:error, reason}`
  """
  def monitor_build(provider, project_dir, opts \\ []) do
    language = Keyword.get(opts, :language, :elixir)
    broadcast = Keyword.get(opts, :broadcast, true)

    Logger.info("#{provider}: Starting build monitoring...")

    if broadcast do
      broadcast_event(provider, :build_started, %{project_dir: project_dir})
    end

    start_time = System.monotonic_time(:millisecond)

    result =
      case language do
        :elixir -> monitor_elixir_build(provider, project_dir, broadcast)
        :python -> monitor_python_build(provider, project_dir, broadcast)
        :javascript -> monitor_javascript_build(provider, project_dir, broadcast)
        _ -> {:error, :unsupported_language}
      end

    duration = System.monotonic_time(:millisecond) - start_time

    case result do
      {:ok, build_data} ->
        build_result = Map.put(build_data, :duration, duration)

        if broadcast do
          broadcast_event(provider, :build_completed, build_result)
        end

        {:ok, build_result}

      {:error, _reason} = error ->
        if broadcast do
          broadcast_event(provider, :build_failed, %{duration: duration})
        end

        error
    end
  end

  @doc """
  Monitors builds for multiple providers concurrently.

  ## Returns
    Map of provider => build_result
  """
  def monitor_concurrent_builds(providers_and_dirs, opts \\ []) do
    tasks =
      Enum.map(providers_and_dirs, fn {provider, project_dir} ->
        Task.async(fn ->
          {provider, monitor_build(provider, project_dir, opts)}
        end)
      end)

    results = Task.await_many(tasks, 120_000)
    Map.new(results)
  end

  @doc """
  Gets a summary of build results suitable for comparison.
  """
  def summarize_build(build_result) do
    %{
      success: build_result.success,
      duration_ms: build_result.duration,
      warning_count: length(build_result.warnings),
      error_count: length(build_result.errors),
      score: calculate_build_score(build_result)
    }
  end

  # Private Functions - Elixir Build

  defp monitor_elixir_build(provider, project_dir, broadcast) do
    Logger.info("#{provider}: Running mix compile...")

    if broadcast do
      broadcast_event(provider, :build_progress, %{step: "Compiling Elixir files..."})
    end

    result =
      System.cmd("mix", ["compile", "--force"],
        cd: project_dir,
        stderr_to_stdout: true
      )

    case result do
      {output, 0} ->
        warnings = extract_elixir_warnings(output)

        if broadcast and length(warnings) > 0 do
          broadcast_event(provider, :build_warnings, %{
            count: length(warnings),
            warnings: warnings
          })
        end

        {:ok,
         %{
           provider: provider,
           success: true,
           warnings: warnings,
           errors: [],
           output: output,
           timestamp: DateTime.utc_now()
         }}

      {output, _exit_code} ->
        errors = extract_elixir_errors(output)

        if broadcast do
          broadcast_event(provider, :build_errors, %{count: length(errors), errors: errors})
        end

        {:ok,
         %{
           provider: provider,
           success: false,
           warnings: [],
           errors: errors,
           output: output,
           timestamp: DateTime.utc_now()
         }}
    end
  rescue
    error ->
      Logger.error("#{provider}: Build failed - #{Exception.message(error)}")
      {:error, {:build_failed, Exception.message(error)}}
  end

  # Private Functions - Python Build

  defp monitor_python_build(provider, project_dir, broadcast) do
    Logger.info("#{provider}: Checking Python syntax...")

    if broadcast do
      broadcast_event(provider, :build_progress, %{step: "Checking Python syntax..."})
    end

    result =
      System.cmd("python", ["-m", "compileall", "."],
        cd: project_dir,
        stderr_to_stdout: true
      )

    case result do
      {output, 0} ->
        {:ok,
         %{
           provider: provider,
           success: true,
           warnings: [],
           errors: [],
           output: output,
           timestamp: DateTime.utc_now()
         }}

      {output, _} ->
        {:ok,
         %{
           provider: provider,
           success: false,
           warnings: [],
           errors: [output],
           output: output,
           timestamp: DateTime.utc_now()
         }}
    end
  rescue
    _ ->
      {:error, :python_not_available}
  end

  # Private Functions - JavaScript Build

  defp monitor_javascript_build(provider, project_dir, broadcast) do
    Logger.info("#{provider}: Running npm build...")

    if broadcast do
      broadcast_event(provider, :build_progress, %{step: "Running npm build..."})
    end

    result =
      System.cmd("npm", ["run", "build"],
        cd: project_dir,
        stderr_to_stdout: true
      )

    case result do
      {output, 0} ->
        {:ok,
         %{
           provider: provider,
           success: true,
           warnings: [],
           errors: [],
           output: output,
           timestamp: DateTime.utc_now()
         }}

      {output, _} ->
        {:ok,
         %{
           provider: provider,
           success: false,
           warnings: [],
           errors: [output],
           output: output,
           timestamp: DateTime.utc_now()
         }}
    end
  rescue
    _ ->
      {:error, :npm_not_available}
  end

  # Helper Functions

  defp extract_elixir_warnings(output) do
    Regex.scan(~r/warning: (.+?)(?:\n|$)/s, output)
    |> Enum.map(fn [_, warning] -> String.trim(warning) end)
  end

  defp extract_elixir_errors(output) do
    Regex.scan(~r/\*\* \((.+?)\) (.+?)(?:\n\n|$)/s, output)
    |> Enum.map(fn [_, error_type, message] ->
      "#{error_type}: #{String.trim(message)}"
    end)
  end

  defp calculate_build_score(build_result) do
    base_score =
      if build_result.success do
        60
      else
        0
      end

    warning_penalty = min(length(build_result.warnings) * 2, 20)
    error_penalty = min(length(build_result.errors) * 10, 60)

    max(0, base_score + 40 - warning_penalty - error_penalty)
  end

  defp broadcast_event(provider, event_type, data) do
    Phoenix.PubSub.broadcast(
      MultiAgentCoder.PubSub,
      "build:#{provider}",
      {:build_event, event_type, data}
    )
  end
end
