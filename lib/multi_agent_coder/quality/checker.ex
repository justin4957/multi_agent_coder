defmodule MultiAgentCoder.Quality.Checker do
  @moduledoc """
  Runs code quality checks on provider-generated code.

  Checks formatting, linting, static analysis, and code metrics
  for code generated by AI providers.
  """

  require Logger

  @type quality_result :: %{
          provider: atom(),
          passed: boolean(),
          checks: %{
            formatting: check_result(),
            credo: check_result(),
            dialyzer: check_result() | nil
          },
          score: integer(),
          timestamp: DateTime.t()
        }

  @type check_result :: %{
          passed: boolean(),
          issues: list(String.t()),
          output: String.t()
        }

  @doc """
  Runs all quality checks for a provider's code.

  ## Parameters
    - provider: Provider name
    - project_dir: Directory containing the code
    - opts: Options
      - `:language` - Programming language (default: :elixir)
      - `:checks` - List of checks to run (default: [:formatting, :credo])
      - `:broadcast` - Broadcast progress (default: true)

  ## Returns
    `{:ok, quality_result}` or `{:error, reason}`
  """
  def run_quality_checks(provider, project_dir, opts \\ []) do
    language = Keyword.get(opts, :language, :elixir)
    checks = Keyword.get(opts, :checks, [:formatting, :credo])
    broadcast = Keyword.get(opts, :broadcast, true)

    Logger.info("#{provider}: Running quality checks...")

    if broadcast do
      broadcast_event(provider, :quality_started, %{project_dir: project_dir})
    end

    case language do
      :elixir ->
        run_elixir_quality_checks(provider, project_dir, checks, broadcast)

      :python ->
        run_python_quality_checks(provider, project_dir, checks, broadcast)

      _ ->
        {:error, :unsupported_language}
    end
  end

  @doc """
  Runs quality checks for multiple providers concurrently.
  """
  def run_concurrent_quality_checks(providers_and_dirs, opts \\ []) do
    tasks =
      Enum.map(providers_and_dirs, fn {provider, project_dir} ->
        Task.async(fn ->
          {provider, run_quality_checks(provider, project_dir, opts)}
        end)
      end)

    results = Task.await_many(tasks, 120_000)
    Map.new(results)
  end

  @doc """
  Summarizes quality check results.
  """
  def summarize_quality(quality_result) do
    total_checks = map_size(quality_result.checks)

    passed_checks =
      quality_result.checks
      |> Map.values()
      |> Enum.filter(&(&1 != nil))
      |> Enum.count(& &1.passed)

    total_issues =
      quality_result.checks
      |> Map.values()
      |> Enum.filter(&(&1 != nil))
      |> Enum.flat_map(& &1.issues)
      |> length()

    %{
      passed: quality_result.passed,
      passed_checks: passed_checks,
      total_checks: total_checks,
      total_issues: total_issues,
      score: quality_result.score
    }
  end

  # Private Functions - Elixir Quality Checks

  defp run_elixir_quality_checks(provider, project_dir, checks, broadcast) do
    check_results = %{
      formatting: if(:formatting in checks, do: check_elixir_formatting(project_dir), else: nil),
      credo: if(:credo in checks, do: check_elixir_credo(project_dir), else: nil),
      dialyzer: if(:dialyzer in checks, do: check_elixir_dialyzer(project_dir), else: nil)
    }

    all_passed =
      check_results
      |> Map.values()
      |> Enum.filter(&(&1 != nil))
      |> Enum.all?(& &1.passed)

    score = calculate_quality_score(check_results)

    if broadcast do
      broadcast_event(provider, :quality_completed, %{passed: all_passed, score: score})
    end

    {:ok,
     %{
       provider: provider,
       passed: all_passed,
       checks: check_results,
       score: score,
       timestamp: DateTime.utc_now()
     }}
  end

  defp check_elixir_formatting(project_dir) do
    Logger.info("Checking Elixir code formatting...")

    result =
      System.cmd("mix", ["format", "--check-formatted"],
        cd: project_dir,
        stderr_to_stdout: true
      )

    case result do
      {_output, 0} ->
        %{
          passed: true,
          issues: [],
          output: "All files properly formatted"
        }

      {output, _} ->
        files_needing_format = extract_unformatted_files(output)

        %{
          passed: false,
          issues: files_needing_format,
          output: output
        }
    end
  rescue
    _ ->
      %{passed: true, issues: [], output: "mix format not available"}
  end

  defp check_elixir_credo(project_dir) do
    Logger.info("Running Credo...")

    result =
      System.cmd("mix", ["credo", "--strict"],
        cd: project_dir,
        stderr_to_stdout: true
      )

    case result do
      {output, 0} ->
        %{
          passed: true,
          issues: [],
          output: output
        }

      {output, _} ->
        issues = extract_credo_issues(output)

        %{
          passed: false,
          issues: issues,
          output: output
        }
    end
  rescue
    _ ->
      %{passed: true, issues: [], output: "Credo not available"}
  end

  defp check_elixir_dialyzer(project_dir) do
    Logger.info("Running Dialyzer...")

    result =
      System.cmd("mix", ["dialyzer", "--format", "short"],
        cd: project_dir,
        stderr_to_stdout: true,
        env: [{"MIX_ENV", "test"}]
      )

    case result do
      {output, 0} ->
        %{
          passed: true,
          issues: [],
          output: output
        }

      {output, _} ->
        issues = extract_dialyzer_issues(output)

        %{
          passed: false,
          issues: issues,
          output: output
        }
    end
  rescue
    _ ->
      %{passed: true, issues: [], output: "Dialyzer not available"}
  end

  # Private Functions - Python Quality Checks

  defp run_python_quality_checks(provider, project_dir, checks, broadcast) do
    check_results = %{
      formatting: if(:formatting in checks, do: check_python_formatting(project_dir), else: nil),
      credo: if(:pylint in checks, do: check_python_pylint(project_dir), else: nil),
      dialyzer: nil
    }

    all_passed =
      check_results
      |> Map.values()
      |> Enum.filter(&(&1 != nil))
      |> Enum.all?(& &1.passed)

    score = calculate_quality_score(check_results)

    if broadcast do
      broadcast_event(provider, :quality_completed, %{passed: all_passed, score: score})
    end

    {:ok,
     %{
       provider: provider,
       passed: all_passed,
       checks: check_results,
       score: score,
       timestamp: DateTime.utc_now()
     }}
  end

  defp check_python_formatting(project_dir) do
    Logger.info("Checking Python formatting with black...")

    result =
      System.cmd("black", ["--check", "."],
        cd: project_dir,
        stderr_to_stdout: true
      )

    case result do
      {_output, 0} ->
        %{passed: true, issues: [], output: "All files properly formatted"}

      {output, _} ->
        %{passed: false, issues: ["Files need formatting"], output: output}
    end
  rescue
    _ ->
      %{passed: true, issues: [], output: "black not available"}
  end

  defp check_python_pylint(project_dir) do
    Logger.info("Running pylint...")

    result =
      System.cmd("pylint", ["--output-format=text", "."],
        cd: project_dir,
        stderr_to_stdout: true
      )

    case result do
      {output, 0} ->
        %{passed: true, issues: [], output: output}

      {output, _} ->
        %{passed: false, issues: ["Pylint issues found"], output: output}
    end
  rescue
    _ ->
      %{passed: true, issues: [], output: "pylint not available"}
  end

  # Helper Functions

  defp extract_unformatted_files(output) do
    Regex.scan(~r/\*\* \(Mix\) (.+\.exs?)/, output)
    |> Enum.map(fn [_, file] -> file end)
  end

  defp extract_credo_issues(output) do
    Regex.scan(~r/\[.\] (.+)/, output)
    |> Enum.map(fn [_, issue] -> String.trim(issue) end)
    |> Enum.take(10)
  end

  defp extract_dialyzer_issues(output) do
    Regex.scan(~r/(.+\.ex:\d+:.+)/, output)
    |> Enum.map(fn [_, issue] -> String.trim(issue) end)
    |> Enum.take(10)
  end

  defp calculate_quality_score(check_results) do
    checks = Map.values(check_results) |> Enum.filter(&(&1 != nil))

    if length(checks) == 0 do
      100
    else
      passed_count = Enum.count(checks, & &1.passed)
      total_checks = length(checks)

      # Base score from passing checks
      base_score = round(passed_count / total_checks * 70)

      # Penalty for issues
      total_issues =
        checks
        |> Enum.flat_map(& &1.issues)
        |> length()

      issue_penalty = min(total_issues * 3, 30)

      max(0, base_score + 30 - issue_penalty)
    end
  end

  defp broadcast_event(provider, event_type, data) do
    Phoenix.PubSub.broadcast(
      MultiAgentCoder.PubSub,
      "quality:#{provider}",
      {:quality_event, event_type, data}
    )
  end
end
